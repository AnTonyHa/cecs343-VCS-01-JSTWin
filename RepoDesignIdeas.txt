Design of Repo Object
1. Each repo is a folder in the root folder of the project tree
	- e.g. If we had a project contained within the folder myProject/ at path 
	C:/User/Desktop/myProject/, the repo would be at C:/User/Desktop/myProject/.git/ 
	(or any other name for the repo folder, such as .JSTWepo/)

2. Each repo has a single branch. Branching functionality can be added, 
but I don't think we have the time to implement it, 
considering we would have to handle merging and merge conflicts.
	- This branch is described by the version control tree (VCTree) each VCtree has a head 	
	VCnode (manifest file), the most current "snapshot" of the project (a collection of the 	
	most recent versions of all files within the project tree).

	- Each VCNode additionally points to the previous VCNode in the event that a rollback 	
	is desired
		- Somewhere in the manifest file, we just need to write the name of the 			
		previous manifest file or we can just increment manifest files (.man-1 is newer 			
		than .man-2, etc. to rollback, we just decrement the manifest file name)
		- This linked-list like implementation is essentially what the entire repo is

3. A repo needs a way to be created, we have already defined a command "create-repo" 
to perform this job
	- In the root folder of the project tree, a new folder must be created if one does not yet 	
	exist. If a repo already exists, we must throw an exception and reccommend the user 	
	use the "add" command instead

	- If the repo doesn't exist, we should traverse the project tree, beginning from the root 	
	folder and traversing down with BFS. Each file should have their relative path from the 	
	project root saved as well as their checksum. This data should be added to a list 	
	(fileList) for later processing.

	- Once we have traversed the entire project tree, we need to create a manifest file to 	
	save the "snapshot" of the project. Since this is the first VCnode in the VCtree, there is 	
	no previous VCnode to be tracked in the manifest file

	- Manifest files can be simply stored in the .git/ repo or we can create a seperate folder 	
	for them, the path would be something like myProject/.git/.man/.man1.txt

	- We should also track the head node, we could write a file called something 	
	like .repoInfo.txt, but I'm not sure ***open for discussion***

4. A repo needs an "add" command to prepare a "staging area" for new commits
	- add takes on two different parameters, files or folders
		- Folders need to be BFS'ed to identify all of the files to be added to the staging 		
		area
		- When you add a file, save the file name and file path

	- If you attempt to add a file that doesn't exist, an exception is thrown

5. A repo needs a "delete" command to delete files or even entire directories from repos
	- delete will not actually delete old files as they belong to prior snapshots, but it will 	
	not include them in new manifest files. This will work just like the staging area, only 	
	that when prompted the files will be "deleted" instead of added

	- If you attempt to delete a file that doesn't exists, an exception is thrown

	- If you attempt to delete a file in the staging area, an exception is thrown

6. ***Frill*** A repo could use a "remove" command to remove any files or folders from the staging 
area that were accidentally added
	- The issue is that if we want to remove an entire folder, we would have to find a way 	
	to easily just delete that information from the staging area. Removing a file is pretty 	
	self explanatory. If the file is in the staging area, simply remove it from the staging area 	
	(not the actual file)

7. A repo must then be able to "commit" all of the files in the staging area.
	- commit is a command without any parameters. Staging area is an attribute of the 	
	repo, so it is implicitly accessed.

	- Parse the previous manifest file and create a fileList containing all of the files in the 	
	previous snapshot, all of their checksums, and all of their paths

	- When you commit the files within the staging area, each added file should have their 	
	path cross referenced with the paths in the previous manifest file, if the path is in the 	
	previous manifest file, calculate the checksum of the added file. If it is different, write 	
	the new file's information (checksum, path, filename) into a new manifest file and 	
	delete the information from the previous version of the file from the fileList. Continue 	
	until you have processed all of the files in the staging area. Once all the proper files 	
	have been added, it is now time to delete files/ folders. Check for each file that 	
	matches the path or each folder that matches the path and remove them from the 	
	fileList so that they do not find their way into the new manifest file.Then, copy over the 	
	rest of the fileList into the new manifest file. As before, the new manifest file should 	
	point to the old manifest file, or we can use the ascending order naming convention 	
	and simply change our new head to this new manifest file. We can also add dates to 	
	our manifest files for logging.

8. A repo needs a way of communicating with the user what previous snapshots exist
	- We could have a command like how git does it with git log. This will output a list of all 	
	of the manifest file names starting with the current head and descending

9. A repo must be able to "roll-back" to previous versions
	- I'm not sure how to implement this one yet, but I assume the person can either pass 	
	the command and we rollback to the previous state or we could have them to pass the 	
	actual manifest name. If we commit again while rolled back, all subsequent manifest 	
	files should be deleted I would assume, because they no longer exist in the new 	
	VCTree
	- git does this with git revert <commit name>
